type Location = [number, number];
type LocationString = `${number},${number}`;

function calculateGcd(a: number, b: number): number {
  return b === 0 ? a : calculateGcd(b, a % b);
}

function printGrid(grid: string[], antinodes: Set<LocationString>): void {
  const rows = grid.length;
  const cols = grid[0].length;

  for (let i = 0; i < rows; i++) {
    let row = '';
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] !== '.') {
        row += grid[i][j];
      } else if (antinodes.has(`${i},${j}`)) {
        row += '#';
      } else {
        row += grid[i][j];
      }
    }
    console.log(row);
  }
}

async function main() {
  const file = Bun.file('./input.txt');
  const input = await file.text();
  const lines = input.split('\n');

  const rows = lines.length;
  const cols = lines[0].length;

  const map: Record<string, Location[]> = {};

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const char = lines[i][j];
      if (char === '.') continue;

      if (!map[char]) map[char] = [[i, j]];
      else map[char].push([i, j]);
    }
  }

  const antinodes = new Set<LocationString>();

  function isOutOfBound(x: number, y: number) {
    return x < 0 || x >= rows || y < 0 || y >= cols;
  }

  Object.values(map).forEach((antennas) => {
    for (let i = 0; i < antennas.length; i++) {
      for (let j = i + 1; j < antennas.length; j++) {
        const [x1, y1] = antennas[i];
        const [x2, y2] = antennas[j];

        // add the antennas themselves as antinodes
        antinodes.add(`${x1},${y1}`);
        antinodes.add(`${x2},${y2}`);

        // find the vectors generated by the antennas
        const diffs: Location = [x2 - x1, y2 - y1];
        const gcd = calculateGcd(diffs[0], diffs[1]);
        const vector: Location = [diffs[0] / gcd, diffs[1] / gcd];

        let [x, y] = [x1, y1];
        while (true) {
          x += vector[0];
          y += vector[1];
          if (isOutOfBound(x, y)) break;
          antinodes.add(`${x},${y}`);
        }

        [x, y] = [x1, y1];
        while (true) {
          x -= vector[0];
          y -= vector[1];
          if (isOutOfBound(x, y)) break;
          antinodes.add(`${x},${y}`);
        }
      }
    }
  });

  printGrid(lines, antinodes);

  console.log(antinodes.size);
}

main();
